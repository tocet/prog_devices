# -*- coding: utf-8 -*-
"""python_ex03_oop.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h7k2N69aauGEYZI9AOkA7XMlEcF9SIfA

**Ex 1. Class definition**
"""

class Point:
  def __init__(self,x_val,y_val):
    self.x = x_val
    self.y = y_val

  def distance(self, other):
    diff_x = (self.x - other.x) ** 2
    diff_y = (self.y - other.y) ** 2
    return (diff_x + diff_y) ** 0.5

p_1 = Point(3,4)
p_2 = Point(1,2)
print(p_1.distance(p_2))
print(Point.distance(p_1,p_2))

class Point:
  def __init__(self,x_val,y_val):
    self.x = x_val
    self.y = y_val

  def distance(self, other):
    diff_x = (self.x - other.x) ** 2
    diff_y = (self.y - other.y) ** 2
    return (diff_x + diff_y) ** 0.5

class Circle:
  def __init__(self,radius,center):
    if type(center) != Point:
      raise ValueError()
    if type(radius) != int:
      raise ValueError()
    self.radius = radius
    self.center = center

  def is_inside(self, other_p):
    return other_p.distance(self.center) < self.radius

  def is_inside_2(self, other_p):
    return self.center.distance(other_p) < self.radius

center = Point(1,1)
c = Circle(5,center)
p = Point(3,4)
print(c.is_inside(p))
print(c.is_inside_2(p))

class Point:
  def __init__(self,x_val,y_val):
    self.x = x_val
    self.y = y_val

  def distance(self, other):
    diff_x = (self.x - other.x) ** 2
    diff_y = (self.y - other.y) ** 2
    return (diff_x + diff_y) ** 0.5

class Circle:
  def __init__(self,radius,center):
    if type(center) != Point:
      raise ValueError()
    if type(radius) != int:
      raise ValueError()
    self.radius = radius
    self.center = center

  def is_inside(self, other_p):
    return other_p.distance(self.center) < self.radius

  def is_inside_2(self, other_p):
    return self.center.distance(other_p) < self.radius

c = Circle(5,(0,0))

class Car:
    def __init__(self, make="VW"):
        self.make = make
        self.gear = 0

    def gear_change_up(self):
        if self.gear <= 7:
            self.gear+=1
        print(self.gear)

    def gear_change_down(self):
        if self.gear >= 0:
            self.gear-=1
        print(self.gear)

my_car = Car()
print(my_car.make)
print(my_car.gear)
my_car.gear_change_up()

"""**Ex 2. Dunder methods**

"""

class Fraction():
  def __init__(self,n,d):
    self.num = n
    self.den = d

  def frac_mul(self, oth):
    return (self.num * oth.num)/(self.den * oth.den)

a = Fraction(1,2)
b = Fraction(5,7)
print(a * b)

class Fraction():
  def __init__(self,n,d):
    self.num = n
    self.den = d

  def __mul__(self, other):
    m_num = self.num * other.num
    m_den = self.den * other.den
    return Fraction(m_num,m_den)

a = Fraction(1,2)
b = Fraction(5,7)
print(a * b)

class Fraction():
  def __init__(self,n,d):
    self.num = n
    self.den = d

  def __mul__(self, other):
    m_num = self.num * other.num
    m_den = self.den * other.den
    return Fraction(m_num,m_den)

  def __str__(self):
    return "<" + str(self.num) + "/" + str(self.den) + ">"

a = Fraction(1,2)
b = Fraction(5,7)
print(a * b)
print(a.__mul__(b))
print(Fraction.__mul__(a,b))

class Fraction():
  def __init__(self,n,d):
    self.num = n
    self.den = d

  def __mul__(self, other):
    m_num = self.num * other.num
    m_den = self.den * other.den
    return Fraction(m_num,m_den)

  def __str__(self):
    return "<" + str(self.num) + "/" + str(self.den) + ">"

  def __float__(self):
    return self.num/self.den

a = Fraction(1,2)
b = Fraction(5,7)
c = a * b
print(c)
print(type(c))
print(float(c))

class Text:
  def __init__(self, text: str) -> None:
    self.text = text

  def __format__(self, format_spec: str) -> str:
    match format_spec:
      case 'upper':
        return self.text.upper()

      case 'lower':
        return self.text.lower()

      case 'count':
        return str(len(self.text))

      case _:
        raise ValueError(f'Format specifier "{format_spec}" does not exist')

txt: Text = Text('Python')
print(f'{txt:upper}')
print(f'{txt:lower}')
print(f'{txt:count}')
print(f'{txt:undescore}')

"""Dunder methods list - https://docs.python.org/3/reference/datamodel.html

**Ex 3. Getters and setters**
"""

class Animal:
  def __init__(self,my_name = "No name"):
    self.name = my_name
    self.age = 0

  def __str__(self):
    return str(self.name) + " is " + str(self.age) + " years old"

  def get_name(self):
    return self.name

  def set_name(self, new_name):
    self.name = new_name

  def get_age(self):
    return self.age

  def set_age(self, new_age = 0):
    self.age = new_age

animal_1 = Animal("Dog")
print(animal_1)
animal_1.set_age(5)
print(animal_1)
print(animal_1.get_age())

"""**Ex 4. Messy code**"""

class Animal:
  def __init__(self,name = "No name"):
    self.name = name
    self.age = 0

  def __str__(self):
    return str(self.name) + " is " + str(self.age) + " years old"

animal_1 = Animal("Cat")
print(animal_1)
animal_1.age = 'infinity'
print(animal_1)
animal_1.weight = 55
print(animal_1.weight)

"""**Ex 5. Inheritance / Dziedziczenie**"""

# parent class / superclass
class Animal:
  def __init__(self, years):
    self.name = None
    self.age = years

  def __str__(self):
    return str(self.name) + " is " + str(self.age) + " years old"

  def get_name(self):
    return self.name

  def set_name(self, new_name):
    self.name = new_name

  def get_age(self):
    return self.age

  def set_age(self, new_age):
    self.age = new_age

# child class / subclass
class Cat(Animal):
  def speak(self):
    print("miau")

  # overriding
  def __str__(self):
     return "Cat " + str(self.name) + " is " + str(self.age) + " years old"

c = Cat(4)
c.set_name("Frosty")
print(c)
c.speak()

class Animal:
  def __init__(self, years):
    self.name = None
    self.age = years

  def __str__(self):
    return str(self.name) + " is " + str(self.age) + " years old"

  def get_name(self):
    return self.name

  def set_name(self, new_name):
    self.name = new_name

  def get_age(self):
    return self.age

  def set_age(self, new_age):
    self.age = new_age

class Human(Animal):
  def __init__(self, name, years):
    Animal.__init__(self, years)
    self.set_name(name)
    self.friends = []

  def add_friend(self,f_name):
    if f_name not in self.friends:
      self.friends.append(f_name)

  def get_friend(self):
    return self.friends.copy()

  def speak(self):
    print("Greetings!!")

class Student(Human):
  def __init__(self, name, age, field_of_study = None):
    Human.__init__(self, name, age)
    self.major = field_of_study

  def change_field_of_study(self, new_major):
    self.major = new_major

  def __str__(self):
    return "Student " + str(self.name) + " studies " + str(self.major)

person_1 = Human("Tom", 25)
person_1.speak()
print(person_1)
person_2 = Student("Tim", 20, "Computer Science")
person_2.speak()
print(person_2)

class Person(object):
    def __init__(self, name, surname, age):
        self.name = name
        self.surname = surname
        self.age = age

    def hasName(self):
        print("Has name")

class Student(Person):
    def __init__(self, name, surname, field_of_study, age):
        super().__init__(name,surname,age)
        self.field_of_study = field_of_study

    def isStudent(self):
        print("Is student")

person_1 = Person("Tom","Nowak",25)
student_1 = Student("Tom", "Nowak" ,"Informatics", 25)
student_1.hasName()

"""**Ex 5. Class variables / Pola statyczne. Static methods / Metody statyczne. Class methods**"""

class Calculator:
  def __init__(self, version):
    self.version = version

  def description(self):
    print(f'Calculator app version {self.version}')

  @staticmethod
  def add_numbers(*numbers):
      return sum(numbers)

calc_1 = Calculator(1)
calc_1.description()
Calculator.add_numbers(1,2,3,4,5,6,100)

from datetime import date

class Car:
  def __init__(self, car_make, car_age):
    self.make = car_make
    self.age = car_age
    print(f'This is {self.make}')

  def car_desc(self):
    print(f'This is {self.make} which is {self.age} years old')

  @classmethod
  def age_from_year(cls, car_make, prod_year):
    current_year = date.today().year
    return cls(car_make, current_year - prod_year)

vw = Car("VW Beetle",20)
vw.car_desc()
ford = Car.age_from_year("Ford Falcon",1955)
ford.car_desc()

from datetime import date

class Car:
  number_of_cars = 0

  def __init__(self, car_make, car_age):
    Car.number_of_cars +=1
    self.make = car_make
    self.age = car_age
    print(f'This is {self.make}')

  def car_desc(self):
    print(f'This is {self.make} which is {self.age} years old')

  @classmethod
  def age_from_year(cls, car_make, prod_year):
    current_year = date.today().year
    return cls(car_make, current_year - prod_year)

  def __del__(self):
    Car.number_of_cars -=1

vw = Car("VW Beetle",20)
vw.car_desc()
print(vw.number_of_cars)
print(f"Total number of cars is {Car.number_of_cars}")
ford = Car.age_from_year("Ford Falcon",1955)
ford.car_desc()
print(f"Total number of cars is {Car.number_of_cars}")
kia = Car.age_from_year("Kia Sportage", 2022)
del(vw)
print(f"VW was scrapped. Total number of cars is {Car.number_of_cars}")
kia = None
print(f"No more Kia. Total number of cars is {Car.number_of_cars}")

"""**Ex 7. Class State Dictionary**"""

class Animal:
  """Doc string"""
  def __init__(self, years):
    self.name = None
    self.age = years

  def __str__(self):
    return str(self.name) + " is " + str(self.age) + " years old"

  def get_name(self):
    return self.name

  def set_name(self, new_name):
    self.name = new_name

  def get_age(self):
    return self.age

  def set_age(self, new_age):
    self.age = new_age

print(Animal.__dict__.keys())
print(Animal.__dict__.values())
help(Animal)
a_1 = Animal(5)
print(a_1.__dict__.keys())
print(a_1.__dict__.values())

"""**Ex 8. Encapsulation / Hermetyzacja**"""

class Encapsulation:
    def __init__(self):
        self.public, self._protected, self.__priv = 1, 2, 3

encaps = Encapsulation()

print(encaps.public)
print(encaps._protected)
try:
  print(encaps.__priv)
except Exception as e:
  print(f'Private attribute access error {e}')

print(encaps._Encapsulation__priv)

class Encapsulation:
  def __init__(self):
      self.public, self._protected, self.__private = 1, 2, 3

  def get_private(self):
    return self.__private

  def set_private(self,prv):
    self.__private = prv

  def __str__(self):
    return f'{self.__private}'

e = Encapsulation()
print(e)
e.set_private(10)
print(e)

"""**Ex 9. *super()***"""

class Shape:
  pi = 3.14

  def __init__(self, colour, is_filled = False):
    self.color = colour
    self.filled = is_filled

  def description(self):
    print(f"It is {'filled' if self.filled else 'not filled'} with {self.color} paint")

class Square(Shape):
  def __init__(self, colour, is_filled, square_width):
    Shape.__init__(self, colour, is_filled)
    self.width = square_width

  def description(self):
    print(f"The area of this square equals {self.width ** 2}")
    Shape.description(self)

class Circle(Shape):
  def __init__(self, colour, is_filled, radius):
    super().__init__(colour, is_filled)
    self.radius = radius

  def description(self):
    print(f"The area of this cricle equals {Shape.pi * (self.radius ** 2)}")
    super().description()

sq_1 = Square('Red', is_filled = True, square_width = 10)
sq_1.description()

c_1 = Circle('Blue', is_filled = False, radius = 5)
c_1.description()

class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width

    def area(self):
        return self.length * self.width

    def perimeter(self):
        return 2 * self.length + 2 * self.width

class Triangle:
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def area(self):
        return 0.5 * self.base * self.height

class Square(Rectangle):
    def __init__(self, length):
        super().__init__(length, length)

class RightPyramid(Square,Triangle):
    def __init__(self, base, slant_height):
        self.base = base
        self.slant_height = slant_height
        super().__init__(self.base)

    def area(self):
        base_area = super().area()
        perimeter = super().perimeter()
        return 0.5 * perimeter * self.slant_height + base_area

block = RightPyramid(2,5)
block.area()